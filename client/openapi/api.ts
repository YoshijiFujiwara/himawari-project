/* tslint:disable */
/* eslint-disable */
/**
 * ひまわりプロジェクト
 * APIドキュメント
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessTokenSerializer
 */
export interface AccessTokenSerializer {
    /**
     * 
     * @type {string}
     * @memberof AccessTokenSerializer
     */
    accessToken: string;
}
/**
 * 
 * @export
 * @interface AssignGoalDto
 */
export interface AssignGoalDto {
    /**
     * 
     * @type {number}
     * @memberof AssignGoalDto
     */
    goalId: number;
}
/**
 * 
 * @export
 * @interface CommitSerializer
 */
export interface CommitSerializer {
    /**
     * 
     * @type {number}
     * @memberof CommitSerializer
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof CommitSerializer
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof CommitSerializer
     */
    description: string;
    /**
     * 
     * @type {number}
     * @memberof CommitSerializer
     */
    studyHours: number;
    /**
     * 
     * @type {number}
     * @memberof CommitSerializer
     */
    studyMinutes: number;
    /**
     * 
     * @type {number}
     * @memberof CommitSerializer
     */
    goalId: number;
    /**
     * 
     * @type {string}
     * @memberof CommitSerializer
     */
    createdAt: string;
    /**
     * 
     * @type {GoalSerializer}
     * @memberof CommitSerializer
     */
    goal?: GoalSerializer;
}
/**
 * 
 * @export
 * @interface CommitTimelineSerializer
 */
export interface CommitTimelineSerializer {
    /**
     * 
     * @type {number}
     * @memberof CommitTimelineSerializer
     */
    id: number;
    /**
     * 
     * @type {CommitSerializer}
     * @memberof CommitTimelineSerializer
     */
    commit: CommitSerializer;
}
/**
 * 
 * @export
 * @interface CommitsSummary
 */
export interface CommitsSummary {
    /**
     * 
     * @type {string}
     * @memberof CommitsSummary
     */
    totalTime: string;
    /**
     * 
     * @type {number}
     * @memberof CommitsSummary
     */
    totalCount: number;
}
/**
 * 
 * @export
 * @interface CreateCommitDto
 */
export interface CreateCommitDto {
    /**
     * 
     * @type {string}
     * @memberof CreateCommitDto
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCommitDto
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateCommitDto
     */
    studyHours: number;
    /**
     * 
     * @type {number}
     * @memberof CreateCommitDto
     */
    studyMinutes: number;
}
/**
 * 
 * @export
 * @interface CreateGoalDto
 */
export interface CreateGoalDto {
    /**
     * 
     * @type {string}
     * @memberof CreateGoalDto
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGoalDto
     */
    description?: string;
    /**
     * publicに公開するか否か
     * @type {boolean}
     * @memberof CreateGoalDto
     */
    isPublic: boolean;
}
/**
 * 
 * @export
 * @interface CreateGroupDto
 */
export interface CreateGroupDto {
    /**
     * 
     * @type {string}
     * @memberof CreateGroupDto
     */
    name: string;
}
/**
 * 
 * @export
 * @interface CreateTaskDto
 */
export interface CreateTaskDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDto
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDto
     */
    description: string;
}
/**
 * 
 * @export
 * @interface GoalSerializer
 */
export interface GoalSerializer {
    /**
     * 
     * @type {number}
     * @memberof GoalSerializer
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof GoalSerializer
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof GoalSerializer
     */
    description: string;
    /**
     * 
     * @type {boolean}
     * @memberof GoalSerializer
     */
    isPublic: boolean;
    /**
     * 
     * @type {number}
     * @memberof GoalSerializer
     */
    userId: number;
    /**
     * 
     * @type {string}
     * @memberof GoalSerializer
     */
    createdAt: string;
    /**
     * 
     * @type {UserSerializer}
     * @memberof GoalSerializer
     */
    user?: UserSerializer;
    /**
     * 
     * @type {Array<CommitSerializer>}
     * @memberof GoalSerializer
     */
    commits?: Array<CommitSerializer>;
}
/**
 * 
 * @export
 * @interface GroupSerializer
 */
export interface GroupSerializer {
    /**
     * 
     * @type {number}
     * @memberof GroupSerializer
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof GroupSerializer
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GroupSerializer
     */
    createdAt: string;
    /**
     * 
     * @type {Array<UserSerializer>}
     * @memberof GroupSerializer
     */
    users?: Array<UserSerializer>;
}
/**
 * 
 * @export
 * @interface InviteUserDto
 */
export interface InviteUserDto {
    /**
     * 
     * @type {string}
     * @memberof InviteUserDto
     */
    email: string;
}
/**
 * 
 * @export
 * @interface MonthlyCount
 */
export interface MonthlyCount {
    /**
     * 
     * @type {string}
     * @memberof MonthlyCount
     */
    createdAt: string;
    /**
     * 
     * @type {number}
     * @memberof MonthlyCount
     */
    count: number;
}
/**
 * 
 * @export
 * @interface SignInUserDto
 */
export interface SignInUserDto {
    /**
     * 
     * @type {string}
     * @memberof SignInUserDto
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof SignInUserDto
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof SignInUserDto
     */
    password: string;
}
/**
 * 
 * @export
 * @interface SignUpUserDto
 */
export interface SignUpUserDto {
    /**
     * 
     * @type {string}
     * @memberof SignUpUserDto
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpUserDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpUserDto
     */
    password: string;
}
/**
 * 
 * @export
 * @interface TaskSerializer
 */
export interface TaskSerializer {
    /**
     * 
     * @type {number}
     * @memberof TaskSerializer
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof TaskSerializer
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSerializer
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSerializer
     */
    status: string;
}
/**
 * 
 * @export
 * @interface UpdateMeDto
 */
export interface UpdateMeDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateMeDto
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMeDto
     */
    avatarUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMeDto
     */
    statusMessage?: string;
}
/**
 * 
 * @export
 * @interface UserAndTokenSerializer
 */
export interface UserAndTokenSerializer {
    /**
     * 
     * @type {UserSerializer}
     * @memberof UserAndTokenSerializer
     */
    me: UserSerializer;
    /**
     * 
     * @type {string}
     * @memberof UserAndTokenSerializer
     */
    accessToken: string;
}
/**
 * 
 * @export
 * @interface UserSerializer
 */
export interface UserSerializer {
    /**
     * 
     * @type {number}
     * @memberof UserSerializer
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof UserSerializer
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof UserSerializer
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof UserSerializer
     */
    avatarUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSerializer
     */
    statusMessage?: string;
    /**
     * 
     * @type {Array<GroupSerializer>}
     * @memberof UserSerializer
     */
    groups?: Array<GroupSerializer>;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGoogleLogin: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/google`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGoogleLoginCallback: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/google/callback`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerMe: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignInUserDto} signInUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignIn: async (signInUserDto: SignInUserDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'signInUserDto' is not null or undefined
            if (signInUserDto === null || signInUserDto === undefined) {
                throw new RequiredError('signInUserDto','Required parameter signInUserDto was null or undefined when calling authControllerSignIn.');
            }
            const localVarPath = `/api/auth/signin`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof signInUserDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(signInUserDto !== undefined ? signInUserDto : {}) : (signInUserDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignUpUserDto} signUpUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignUp: async (signUpUserDto: SignUpUserDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpUserDto' is not null or undefined
            if (signUpUserDto === null || signUpUserDto === undefined) {
                throw new RequiredError('signUpUserDto','Required parameter signUpUserDto was null or undefined when calling authControllerSignUp.');
            }
            const localVarPath = `/api/auth/signup`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof signUpUserDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(signUpUserDto !== undefined ? signUpUserDto : {}) : (signUpUserDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateMeDto} updateMeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerUpdateMe: async (updateMeDto: UpdateMeDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateMeDto' is not null or undefined
            if (updateMeDto === null || updateMeDto === undefined) {
                throw new RequiredError('updateMeDto','Required parameter updateMeDto was null or undefined when calling authControllerUpdateMe.');
            }
            const localVarPath = `/api/auth/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateMeDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateMeDto !== undefined ? updateMeDto : {}) : (updateMeDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyEmail: async (token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling authControllerVerifyEmail.');
            }
            const localVarPath = `/api/auth/email/verify/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGoogleLogin(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authControllerGoogleLogin(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGoogleLoginCallback(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authControllerGoogleLoginCallback(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerMe(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSerializer>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authControllerMe(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {SignInUserDto} signInUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignIn(signInUserDto: SignInUserDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenSerializer>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authControllerSignIn(signInUserDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {SignUpUserDto} signUpUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignUp(signUpUserDto: SignUpUserDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authControllerSignUp(signUpUserDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UpdateMeDto} updateMeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerUpdateMe(updateMeDto: UpdateMeDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAndTokenSerializer>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authControllerUpdateMe(updateMeDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerVerifyEmail(token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authControllerVerifyEmail(token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGoogleLogin(options?: any): AxiosPromise<void> {
            return AuthApiFp(configuration).authControllerGoogleLogin(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGoogleLoginCallback(options?: any): AxiosPromise<void> {
            return AuthApiFp(configuration).authControllerGoogleLoginCallback(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerMe(options?: any): AxiosPromise<UserSerializer> {
            return AuthApiFp(configuration).authControllerMe(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignInUserDto} signInUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignIn(signInUserDto: SignInUserDto, options?: any): AxiosPromise<AccessTokenSerializer> {
            return AuthApiFp(configuration).authControllerSignIn(signInUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignUpUserDto} signUpUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignUp(signUpUserDto: SignUpUserDto, options?: any): AxiosPromise<void> {
            return AuthApiFp(configuration).authControllerSignUp(signUpUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateMeDto} updateMeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerUpdateMe(updateMeDto: UpdateMeDto, options?: any): AxiosPromise<UserAndTokenSerializer> {
            return AuthApiFp(configuration).authControllerUpdateMe(updateMeDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyEmail(token: string, options?: any): AxiosPromise<void> {
            return AuthApiFp(configuration).authControllerVerifyEmail(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGoogleLogin(options?: any) {
        return AuthApiFp(this.configuration).authControllerGoogleLogin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGoogleLoginCallback(options?: any) {
        return AuthApiFp(this.configuration).authControllerGoogleLoginCallback(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerMe(options?: any) {
        return AuthApiFp(this.configuration).authControllerMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignInUserDto} signInUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignIn(signInUserDto: SignInUserDto, options?: any) {
        return AuthApiFp(this.configuration).authControllerSignIn(signInUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignUpUserDto} signUpUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignUp(signUpUserDto: SignUpUserDto, options?: any) {
        return AuthApiFp(this.configuration).authControllerSignUp(signUpUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateMeDto} updateMeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerUpdateMe(updateMeDto: UpdateMeDto, options?: any) {
        return AuthApiFp(this.configuration).authControllerUpdateMe(updateMeDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerVerifyEmail(token: string, options?: any) {
        return AuthApiFp(this.configuration).authControllerVerifyEmail(token, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CommitsApi - axios parameter creator
 * @export
 */
export const CommitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} goalId 
         * @param {CreateCommitDto} createCommitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitsControllerCreateCommit: async (goalId: number, createCommitDto: CreateCommitDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalId' is not null or undefined
            if (goalId === null || goalId === undefined) {
                throw new RequiredError('goalId','Required parameter goalId was null or undefined when calling commitsControllerCreateCommit.');
            }
            // verify required parameter 'createCommitDto' is not null or undefined
            if (createCommitDto === null || createCommitDto === undefined) {
                throw new RequiredError('createCommitDto','Required parameter createCommitDto was null or undefined when calling commitsControllerCreateCommit.');
            }
            const localVarPath = `/api/goals/{goal_id}/commits`
                .replace(`{${"goal_id"}}`, encodeURIComponent(String(goalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createCommitDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createCommitDto !== undefined ? createCommitDto : {}) : (createCommitDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitsControllerDeleteCommit: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling commitsControllerDeleteCommit.');
            }
            const localVarPath = `/api/commits/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitsControllerGetCommits: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/commits`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitsControllerGetMonthlyCountByUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/commits/summary/monthly`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitsControllerGetSummaryByUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/commits/summary/total`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommitsApi - functional programming interface
 * @export
 */
export const CommitsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} goalId 
         * @param {CreateCommitDto} createCommitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commitsControllerCreateCommit(goalId: number, createCommitDto: CreateCommitDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitSerializer>> {
            const localVarAxiosArgs = await CommitsApiAxiosParamCreator(configuration).commitsControllerCreateCommit(goalId, createCommitDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commitsControllerDeleteCommit(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CommitsApiAxiosParamCreator(configuration).commitsControllerDeleteCommit(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commitsControllerGetCommits(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommitSerializer>>> {
            const localVarAxiosArgs = await CommitsApiAxiosParamCreator(configuration).commitsControllerGetCommits(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commitsControllerGetMonthlyCountByUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MonthlyCount>>> {
            const localVarAxiosArgs = await CommitsApiAxiosParamCreator(configuration).commitsControllerGetMonthlyCountByUser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commitsControllerGetSummaryByUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitsSummary>> {
            const localVarAxiosArgs = await CommitsApiAxiosParamCreator(configuration).commitsControllerGetSummaryByUser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CommitsApi - factory interface
 * @export
 */
export const CommitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {number} goalId 
         * @param {CreateCommitDto} createCommitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitsControllerCreateCommit(goalId: number, createCommitDto: CreateCommitDto, options?: any): AxiosPromise<CommitSerializer> {
            return CommitsApiFp(configuration).commitsControllerCreateCommit(goalId, createCommitDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitsControllerDeleteCommit(id: number, options?: any): AxiosPromise<void> {
            return CommitsApiFp(configuration).commitsControllerDeleteCommit(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitsControllerGetCommits(options?: any): AxiosPromise<Array<CommitSerializer>> {
            return CommitsApiFp(configuration).commitsControllerGetCommits(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitsControllerGetMonthlyCountByUser(options?: any): AxiosPromise<Array<MonthlyCount>> {
            return CommitsApiFp(configuration).commitsControllerGetMonthlyCountByUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitsControllerGetSummaryByUser(options?: any): AxiosPromise<CommitsSummary> {
            return CommitsApiFp(configuration).commitsControllerGetSummaryByUser(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommitsApi - object-oriented interface
 * @export
 * @class CommitsApi
 * @extends {BaseAPI}
 */
export class CommitsApi extends BaseAPI {
    /**
     * 
     * @param {number} goalId 
     * @param {CreateCommitDto} createCommitDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommitsApi
     */
    public commitsControllerCreateCommit(goalId: number, createCommitDto: CreateCommitDto, options?: any) {
        return CommitsApiFp(this.configuration).commitsControllerCreateCommit(goalId, createCommitDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommitsApi
     */
    public commitsControllerDeleteCommit(id: number, options?: any) {
        return CommitsApiFp(this.configuration).commitsControllerDeleteCommit(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommitsApi
     */
    public commitsControllerGetCommits(options?: any) {
        return CommitsApiFp(this.configuration).commitsControllerGetCommits(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommitsApi
     */
    public commitsControllerGetMonthlyCountByUser(options?: any) {
        return CommitsApiFp(this.configuration).commitsControllerGetMonthlyCountByUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommitsApi
     */
    public commitsControllerGetSummaryByUser(options?: any) {
        return CommitsApiFp(this.configuration).commitsControllerGetSummaryByUser(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GoalsApi - axios parameter creator
 * @export
 */
export const GoalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateGoalDto} createGoalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        goalsControllerCreateGoal: async (createGoalDto: CreateGoalDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGoalDto' is not null or undefined
            if (createGoalDto === null || createGoalDto === undefined) {
                throw new RequiredError('createGoalDto','Required parameter createGoalDto was null or undefined when calling goalsControllerCreateGoal.');
            }
            const localVarPath = `/api/goals`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createGoalDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createGoalDto !== undefined ? createGoalDto : {}) : (createGoalDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        goalsControllerGetGoal: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling goalsControllerGetGoal.');
            }
            const localVarPath = `/api/goals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        goalsControllerGetGoals: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/goals`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoalsApi - functional programming interface
 * @export
 */
export const GoalsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateGoalDto} createGoalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async goalsControllerCreateGoal(createGoalDto: CreateGoalDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoalSerializer>> {
            const localVarAxiosArgs = await GoalsApiAxiosParamCreator(configuration).goalsControllerCreateGoal(createGoalDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async goalsControllerGetGoal(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoalSerializer>> {
            const localVarAxiosArgs = await GoalsApiAxiosParamCreator(configuration).goalsControllerGetGoal(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async goalsControllerGetGoals(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GoalSerializer>>> {
            const localVarAxiosArgs = await GoalsApiAxiosParamCreator(configuration).goalsControllerGetGoals(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GoalsApi - factory interface
 * @export
 */
export const GoalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {CreateGoalDto} createGoalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        goalsControllerCreateGoal(createGoalDto: CreateGoalDto, options?: any): AxiosPromise<GoalSerializer> {
            return GoalsApiFp(configuration).goalsControllerCreateGoal(createGoalDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        goalsControllerGetGoal(id: number, options?: any): AxiosPromise<GoalSerializer> {
            return GoalsApiFp(configuration).goalsControllerGetGoal(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        goalsControllerGetGoals(options?: any): AxiosPromise<Array<GoalSerializer>> {
            return GoalsApiFp(configuration).goalsControllerGetGoals(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GoalsApi - object-oriented interface
 * @export
 * @class GoalsApi
 * @extends {BaseAPI}
 */
export class GoalsApi extends BaseAPI {
    /**
     * 
     * @param {CreateGoalDto} createGoalDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public goalsControllerCreateGoal(createGoalDto: CreateGoalDto, options?: any) {
        return GoalsApiFp(this.configuration).goalsControllerCreateGoal(createGoalDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public goalsControllerGetGoal(id: number, options?: any) {
        return GoalsApiFp(this.configuration).goalsControllerGetGoal(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public goalsControllerGetGoals(options?: any) {
        return GoalsApiFp(this.configuration).goalsControllerGetGoals(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {AssignGoalDto} assignGoalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerAssignGoal: async (id: number, assignGoalDto: AssignGoalDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling groupsControllerAssignGoal.');
            }
            // verify required parameter 'assignGoalDto' is not null or undefined
            if (assignGoalDto === null || assignGoalDto === undefined) {
                throw new RequiredError('assignGoalDto','Required parameter assignGoalDto was null or undefined when calling groupsControllerAssignGoal.');
            }
            const localVarPath = `/api/groups/{id}/goals`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof assignGoalDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(assignGoalDto !== undefined ? assignGoalDto : {}) : (assignGoalDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateGroupDto} createGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerCreateGroup: async (createGroupDto: CreateGroupDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGroupDto' is not null or undefined
            if (createGroupDto === null || createGroupDto === undefined) {
                throw new RequiredError('createGroupDto','Required parameter createGroupDto was null or undefined when calling groupsControllerCreateGroup.');
            }
            const localVarPath = `/api/groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createGroupDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createGroupDto !== undefined ? createGroupDto : {}) : (createGroupDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerGetGroup: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling groupsControllerGetGroup.');
            }
            const localVarPath = `/api/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {InviteUserDto} inviteUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerInviteUser: async (id: number, inviteUserDto: InviteUserDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling groupsControllerInviteUser.');
            }
            // verify required parameter 'inviteUserDto' is not null or undefined
            if (inviteUserDto === null || inviteUserDto === undefined) {
                throw new RequiredError('inviteUserDto','Required parameter inviteUserDto was null or undefined when calling groupsControllerInviteUser.');
            }
            const localVarPath = `/api/groups/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inviteUserDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inviteUserDto !== undefined ? inviteUserDto : {}) : (inviteUserDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {AssignGoalDto} assignGoalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsControllerAssignGoal(id: number, assignGoalDto: AssignGoalDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration).groupsControllerAssignGoal(id, assignGoalDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateGroupDto} createGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsControllerCreateGroup(createGroupDto: CreateGroupDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupSerializer>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration).groupsControllerCreateGroup(createGroupDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsControllerGetGroup(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupSerializer>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration).groupsControllerGetGroup(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {InviteUserDto} inviteUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsControllerInviteUser(id: number, inviteUserDto: InviteUserDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration).groupsControllerInviteUser(id, inviteUserDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {AssignGoalDto} assignGoalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerAssignGoal(id: number, assignGoalDto: AssignGoalDto, options?: any): AxiosPromise<void> {
            return GroupsApiFp(configuration).groupsControllerAssignGoal(id, assignGoalDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateGroupDto} createGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerCreateGroup(createGroupDto: CreateGroupDto, options?: any): AxiosPromise<GroupSerializer> {
            return GroupsApiFp(configuration).groupsControllerCreateGroup(createGroupDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerGetGroup(id: number, options?: any): AxiosPromise<GroupSerializer> {
            return GroupsApiFp(configuration).groupsControllerGetGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {InviteUserDto} inviteUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerInviteUser(id: number, inviteUserDto: InviteUserDto, options?: any): AxiosPromise<void> {
            return GroupsApiFp(configuration).groupsControllerInviteUser(id, inviteUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {AssignGoalDto} assignGoalDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerAssignGoal(id: number, assignGoalDto: AssignGoalDto, options?: any) {
        return GroupsApiFp(this.configuration).groupsControllerAssignGoal(id, assignGoalDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateGroupDto} createGroupDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerCreateGroup(createGroupDto: CreateGroupDto, options?: any) {
        return GroupsApiFp(this.configuration).groupsControllerCreateGroup(createGroupDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerGetGroup(id: number, options?: any) {
        return GroupsApiFp(this.configuration).groupsControllerGetGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {InviteUserDto} inviteUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerInviteUser(id: number, inviteUserDto: InviteUserDto, options?: any) {
        return GroupsApiFp(this.configuration).groupsControllerInviteUser(id, inviteUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerCreateTask: async (createTaskDto: CreateTaskDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTaskDto' is not null or undefined
            if (createTaskDto === null || createTaskDto === undefined) {
                throw new RequiredError('createTaskDto','Required parameter createTaskDto was null or undefined when calling tasksControllerCreateTask.');
            }
            const localVarPath = `/api/tasks`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createTaskDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createTaskDto !== undefined ? createTaskDto : {}) : (createTaskDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerDeleteTask: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tasksControllerDeleteTask.');
            }
            const localVarPath = `/api/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerGetTaskById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tasksControllerGetTaskById.');
            }
            const localVarPath = `/api/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerGetTasks: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerUpdateTaskStatus: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tasksControllerUpdateTaskStatus.');
            }
            const localVarPath = `/api/tasks/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerCreateTask(createTaskDto: CreateTaskDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSerializer>> {
            const localVarAxiosArgs = await TasksApiAxiosParamCreator(configuration).tasksControllerCreateTask(createTaskDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerDeleteTask(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TasksApiAxiosParamCreator(configuration).tasksControllerDeleteTask(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerGetTaskById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSerializer>> {
            const localVarAxiosArgs = await TasksApiAxiosParamCreator(configuration).tasksControllerGetTaskById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerGetTasks(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSerializer>>> {
            const localVarAxiosArgs = await TasksApiAxiosParamCreator(configuration).tasksControllerGetTasks(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerUpdateTaskStatus(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSerializer>> {
            const localVarAxiosArgs = await TasksApiAxiosParamCreator(configuration).tasksControllerUpdateTaskStatus(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerCreateTask(createTaskDto: CreateTaskDto, options?: any): AxiosPromise<TaskSerializer> {
            return TasksApiFp(configuration).tasksControllerCreateTask(createTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerDeleteTask(id: number, options?: any): AxiosPromise<void> {
            return TasksApiFp(configuration).tasksControllerDeleteTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerGetTaskById(id: number, options?: any): AxiosPromise<TaskSerializer> {
            return TasksApiFp(configuration).tasksControllerGetTaskById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerGetTasks(options?: any): AxiosPromise<Array<TaskSerializer>> {
            return TasksApiFp(configuration).tasksControllerGetTasks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerUpdateTaskStatus(id: number, options?: any): AxiosPromise<TaskSerializer> {
            return TasksApiFp(configuration).tasksControllerUpdateTaskStatus(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * 
     * @param {CreateTaskDto} createTaskDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerCreateTask(createTaskDto: CreateTaskDto, options?: any) {
        return TasksApiFp(this.configuration).tasksControllerCreateTask(createTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerDeleteTask(id: number, options?: any) {
        return TasksApiFp(this.configuration).tasksControllerDeleteTask(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerGetTaskById(id: number, options?: any) {
        return TasksApiFp(this.configuration).tasksControllerGetTaskById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerGetTasks(options?: any) {
        return TasksApiFp(this.configuration).tasksControllerGetTasks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerUpdateTaskStatus(id: number, options?: any) {
        return TasksApiFp(this.configuration).tasksControllerUpdateTaskStatus(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TimelinesApi - axios parameter creator
 * @export
 */
export const TimelinesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timelinesControllerGetTimelines: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling timelinesControllerGetTimelines.');
            }
            const localVarPath = `/api/groups/{id}/timelines`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimelinesApi - functional programming interface
 * @export
 */
export const TimelinesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timelinesControllerGetTimelines(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommitTimelineSerializer>>> {
            const localVarAxiosArgs = await TimelinesApiAxiosParamCreator(configuration).timelinesControllerGetTimelines(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TimelinesApi - factory interface
 * @export
 */
export const TimelinesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timelinesControllerGetTimelines(id: number, options?: any): AxiosPromise<Array<CommitTimelineSerializer>> {
            return TimelinesApiFp(configuration).timelinesControllerGetTimelines(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimelinesApi - object-oriented interface
 * @export
 * @class TimelinesApi
 * @extends {BaseAPI}
 */
export class TimelinesApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimelinesApi
     */
    public timelinesControllerGetTimelines(id: number, options?: any) {
        return TimelinesApiFp(this.configuration).timelinesControllerGetTimelines(id, options).then((request) => request(this.axios, this.basePath));
    }
}


